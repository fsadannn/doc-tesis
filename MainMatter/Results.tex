\chapter{Experimentos numéricos}\label{chapter:SIMULATION}

En este cap\'{\i}tulo se analizará, mediante simulaciones num\'{e}ricas, el
desempeño de los c\'{o}digos adaptativos conformados por los
esquemas embebidos (\ref{LLDPK scheme}) y (\ref{LLDPKFJ scheme}) con la
estrategia adaptativa presentada en la \-{Secci\'on}~\ref{ADAPT-STR}. Con especial énfasis se evaluar\'a la precisi\'on y costo computacional de los algoritmos en la integración de varias ecuaciones de prueba.


\section{Ecuaciones de prueba}
Todas las ecuaciones de prueba que a continuación se consideran han sido utilizadas previamente en la literatura. Las dos primeras fueron utilizadas
en \cite{Jimenez13}  y las restantes en \cite{tokman,loffeld2013comparative}. En todos los ejemplos con ecuaciones en  derivadas parciales se aplicó el método de lineas para la discretización espacial de esas ecuaciones.
Siguiendo la propuesta de Tokman, para la primera y segunda derivada parcial con respecto las variables espaciales se utilizó la diferencia finita centrada de segundo orden.\\ \\
\
\textbf{Ejemplo 1.} Stiff lineal~\cite{Jimenez13}:
\[ \frac{dx}{dt}= -100\mathbf{H}x \]
con condici\'on inicial $x_{i}=-0\mathord{.}5, i=1,\ldots,500$, y $t\in [0,1]$. Aqui, $\mathbf{H}$ denota a la matriz de Hilbert de dimensi\'on $500$ con n\'umero de condici\'on $1\mathord{.}81\cdot 10^{20}$ con lo cual se tiene que  $\nnorm{f_x}_\infty\approx679$. \\ \\
\textbf{Ejemplo 2.} Stiff lineal m\'as un t\'ermino no lineal~\cite{Jimenez13}:
\[ \frac{dx}{dt}= 100\mathbf{H}(x-1)+100(x-1)^{2}-60(x^{3}-1), \]
donde $\mathbf{H}$ es la matriz de Hilbert de dimensi\'on $500$, con   
condici\'on inicial $x_{i}=-0\mathord{.}5,i=1,\ldots,500$, y $t\in [0,1]$. Para ésta ecuación, el número de condici\'on $"\mathrm{cond}(f_x)"$ de $f_x$
en el intervalo de integración está acotado por $3\leq \mathrm{cond}(f_x)\leq 18$ y para la norma de $f_x$ se cumple que $800\leq\nnorm{f_x}_\infty\leq 1700$.\\ \\
\textbf{Ejemplo 3.} Brusselator~\cite{bruss,tokman} modelo de reacci\'on multimolecular utilizando 
leyes de qu\'imica cin\'etica:
\begin{eqnarray*}
	\frac{\partial u}{\partial t}&=&1+uv^{2}-4u+\alpha \frac{\partial ^{2}u}{\partial x^{2}}\\
	\frac{\partial v}{\partial t}&=&3u-u^{2}v+\alpha \frac{\partial ^{2}v}{\partial x^{2}},
\end{eqnarray*}
donde $\alpha = 0\mathord{.}02$, $t\in [0,1]$ y $0\leq x \leq 1$, con condici\'on inicial y condiciones de frontera:
\begin{eqnarray*}
	u(0,t)=u(1,t)=1 &,& v(0,t)=v(1,t)=3\\
	u(x,0)=1+\sin(2\pi x) &,& v(x,0)=3.
\end{eqnarray*}
El t\'ermino de difusi\'on se discretiz\'o utilizando diferencia finita centrada de segundo orden
en la red $x_i=\frac{i}{N+1}$, con espaciamiento entre los nodos $\Delta x = \frac{1}{N+1}$. Aqui se tiene que $3\cdot 10^4\leq \mathrm{cond}(f_x)\leq 3\cdot 10^5$ y $\nnorm{f_x}_\infty\approx 2\cdot 10^4$.\\ \\
\textbf{Ejemplo 4.} Burgers~\cite{tokman}
\[ u_t+uu_x=\nu u_{xx}, \]
donde $\nu = 3\cdot10^{-4}$, $t\in [0,0\mathord{.}5]$ y $0\leq x\leq 1$, 
con valores iniciales y condiciones de frontera
\begin{equation*}
   u(0,t)=u(1,t)=0 \;\;\; ,   \;\;\;  u(x,0)=(\sin(3\pi x))^{2}(1-x)^{3/2}.
\end{equation*}
El t\'ermino  $uu_x$ fue discretizado como
\[ \frac{u_{i+1}^{2}-u_{i-1}^{2}}{4\Delta x} \;\;\;\;  i=1,\ldots,N.\] Para ésta ecuación se tiene que  
$10^4\leq \mathrm{cond}(f_x)\leq 1\mathord{.}6\cdot 10^4$ y $460\leq\nnorm{f_x}_\infty\leq 540$. \\ \\
\textbf{Ejemplo 5.} CUSP~\cite{tokman} 
\begin{eqnarray*}
	\frac{\partial y}{\partial t} &=& -\frac{y^{3}+ay+b}{\varepsilon}+\sigma\frac{\partial^{2}y}{\partial x^{2}}\\
	\frac{\partial a}{\partial t} &=& b+0\mathord{.}07v+\sigma \frac{\partial^{2}a}{\partial x^{2}}\\
	\frac{\partial b}{\partial t} &=& (1-a^{2})b-a-0\mathord{.}4y+0\mathord{.}035v+\sigma\frac{\partial^{2}b}{\partial x^{2}},
\end{eqnarray*}
donde 
\[ v= \frac{u}{u+0\mathord{.}1},\;\; u=(y-0\mathord{.}7)(y-1\mathord{.}3).\]
Este sistema es la combinación del modelo de mecanismos del umbral del impulso nervioso de Fitz-Hugh y Nagumo en la ecuación de la conducción
 nerviosa~\cite{cusp1,cusp2} junto a la catástrofe \emph{cusp} con retorno amortiguado~\cite{cusp3} y el oscilador de Van der Pol. En
  particular, se considera el dominio $0\leq x\leq 1$ y una discretización sobre una red de $N$ puntos con espaciamiento $\Delta x=1/N$ entre
   los nodos. Condiciones de frontera periódicas son impuestas sobre $y,a,b$ y condiciones iniciales
\[y(x, 0)=0,\;\;a(x, 0)=-\cos(2\pi x),\;\;b(x, 0)=2\sin(2\pi x).\]
Los parámetros en este problema fueron escogidos para que la parte \emph{stiff} provenga de la discretización del término difusivo y del factor $\varepsilon$ que multiplica al término no lineal de la parte derecha de la ecuación. Los valores de los parámetros son $\varepsilon=10^{-4}$ y $\sigma=1/144$, y el intervalo de tiempo  $t\in [0,10^{-4}]$. El n\'umero de condici\'on y norma de $f_x$ en este caso satisfacen  
	$8\cdot 10 ^5\leq \mathrm{cond}(f_x)\leq 4\cdot 10^7$ y $4\cdot 10^4\leq\nnorm{f_x}_\infty\leq 8\cdot 10^4$.\\ \\
\textbf{Ejemplo 6.} DND (\emph{Degenerate nonlinear diffusion 1D})~\cite{dnd,loffeld2013comparative}\\
\[ \frac{\partial u}{\partial t} = \frac{\partial}{\partial x}\left[ u\frac{\partial u}{\partial x} \right] + u(1-u), \]
donde $t\in[0, 0\mathord{.}1]$ y $-23 < x < 50$, con condiciones de frontera $u(-23,t) = 1$ y $u(50,t)=0$ y condiciones iniciales
\[ u(x,0)=\begin{cases}
1 & \text{si }x\leq 0\\
\me{-0\mathord{.}8284x} & \text{si }x>0
\end{cases}. \]
Para esta ecuación se tiene que $ 10^5\leq \mathrm{cond}(f_x)\leq 1\mathord{.}5\cdot 10^{16}$ y $\nnorm{f_x}_\infty\approx 10^6$.
\\ \\
\textbf{Ejemplo 7.} Brusselator 2D~\cite{bruss,loffeld2013comparative}
\begin{eqnarray*}
	 \frac{\partial u}{\partial t} &=&1+uv^{2}-4u+\alpha \nabla^{2}u\\
	\frac{\partial v}{\partial t}&=&3u-u^{2}v+\alpha \nabla^{2}v,
\end{eqnarray*}
donde $\alpha = 0\mathord{.}02$, $t\in[0, 0\mathord{.}1]$ y $x,y\in[0,1]$,
 con condiciones de frontera de Newman y condiciones iniciales: 
\begin{eqnarray*}
u(x,y,0)=1+\sin(2\pi x)\sin(2\pi y) &,& v(x,y,0)=3.
\end{eqnarray*}
El n\'umero de condici\'on y norma de $f_x$ en este caso satisfacen 
$6\cdot 10^3\leq \mathrm{cond}(f_x)\leq 10^4$ y $\nnorm{f_x}_\infty\approx 397\mathord{.}5$.\\ \\
\
\textbf{Ejemplo 8.} Allen-Cahn 2D~\cite{allenchan2d,loffeld2013comparative}
\[ \frac{\partial u}{\partial t} = \alpha\nabla^{2} u + u - u^{3}  \]
con $\alpha=0\mathord{.}1$, $t\in[0, 1]$ y $x,y\in[-1,1]$, condiciones de frontera de Newman y condiciones iniciales:
\[ u(x,y,0)=0\mathord{.}1+0\mathord{.}1\cos(2\pi x)\cos(2\pi y). \]
Para ésta ecuación se cumple que 
$10^4 \leq \mathrm{cond}(f_x)\leq 2\mathord{.}3\cdot10^5$ y $\nnorm{f_x}_\infty\approx 1929\mathord{.}9$.\\ \\
\
\textbf{Ejemplo 9.} Gray-Scott 2D~\cite{grayscott2d,loffeld2013comparative}
\begin{eqnarray*}
	\frac{\partial u}{\partial t} &=& d_u\nabla^{2}u -uv^{2}+a(1-u) \\
	\frac{\partial v}{\partial t} &=& d_v\nabla^{2}v +uv^{2}-(a+b)v
\end{eqnarray*}
con $d_u=0\mathord{.}2,\,d_v=0\mathord{.}1,\,a=0\mathord{.}04,\,b=0\mathord{.}06$, $t\in[0, 0\mathord{.}1]$ y $x,y\in[0,1]$, condiciones de frontera de Newman y condiciones iniciales:
\begin{eqnarray*}
	u(x,y,0) & = & 1-\me{-150\left(x-\frac{1}{2}\right)^{2}+\left(y-\frac{1}{2}\right)^{2}}\\
	v(x,y,0) & = & \me{-150\left(x-\frac{1}{2}\right)^{2}+2\left(y-\frac{1}{2}\right)^{2}}.
\end{eqnarray*}
Aqui se tiene que $10^4\leq \mathrm{cond}(f_x)\leq 1\mathord{.}5\cdot 10^5$ y $\nnorm{f_x}_\infty\approx 3842\mathord{.}7$.

\section{Simulaciones con códigos de paso fijo}\label{Seccion simulacion paso fijo}
El objetivo de este primer conjunto de pruebas es comparar los esquemas localmente linealizados introducidos en las secciones \ref{KRLOV-PADE} y  \ref{KRLOV-PADE-FJ} con conocidos integradores exponenciales de paso fijo y dimensión de Krylov variable como, por ejemplo, los desarrollados en \cite{adams} para EDOs de la forma general (\ref{ODE-SYST}). Para ello se construyeron los c\'odigos Matlab LLRK4k y LLRK5k que implementan, respectivamente, los esquemas de orden 4 y 5 de  (\ref{LLDPK scheme}) con tama\~no de paso fijo y dimensión de Krylov variable tal y como se especifican en la subsección \ref{adaptstratfix}. Para los integradores exponenciales de \cite{adams} de orden 4 y 5 se ultizó el código \textquoteleft expms \textquoteright de \cite{expode}. En lo susesivo denotaremos por expms4 y expms5 el código de los integradores de orden 4 y 5, respectivamente.  

Aquí es importante mencionar que mientras que los códigos LLRK4k y LLRK5k eval\'uan solo una funci\'on $\phi$ en cada paso, los códigos expms4 y expms5 eval\'uan una combinaci\'on lineal de funciones $\phi$ en cada paso lo cual necesariamente agrega un costo computacional extra. Por otra parte, en lugar de la aproximación de Padé, los códigos expms4 y expms5 utilizan la descomposición en valores propios de la matriz de Heissenber producida por el algoritmo de Arnoldi lo cual introduce un coste adicional en la descomposición de Krylov de esos códigos. Con el propósito de preservar el orden de convergencia de los esquemas localmente linealizados determinado por el Teorema \ref{Teorema Convergencia}, se fija $m_{min}=4$ en el esquema LLRK4k y $m_{min}=5$ en el esquema LLRK5k. Los códigos expms4 y expms5 no restringen a $m_{min}$. En los cuatro códigos las tolerancias para el cálculo de los subespacios de Krylov son $10^{-9}$, $10^{-12}$.


Para cada ecuación de prueba, los resultados de la integración con cada uno de los mencionados códigos se sintetizan en una tabla. La precisión de cada código se mide por el error relativo
\[ ER = \max_{i=1,\ldots,d\in(t)_h}\left\lvert\frac{x^{[i]}(t_j)-y^{[i]}(t_j)}{x^{[i]}(t_j)}\right\rvert \]
entre la soluci\'on \textquotedblleft exacta\textquotedblright ~$x$ de la ecuación de prueba y la aproximada $y$ obtenida por cada código. Siguiendo a \cite{tokman}, la solución exacta de todas las ecuaciones de pruebas se estima con el código Matlab ode15s con tolerancias $RTol=10^{-12}$ y $ATol=10^{-14}$. En cada tabla, la columna $Tiempo$ presenta el tiempo de cómputo de cada código relativo al tiempo de cómputo del integrador expms4.  
De esa forma, ese $Tiempo$ relativo sirve como un indicador simple para comparar el tiempo que utiliza cada código al integrar cada ecuación de prueba. 
Ademas, las tablas muestran el número de pasos de integración $NP$ y de evaluaciones del campo vectorial $f$-Evals y de Jacobiano $J$-Evals, así como la dimensión mínima  $\mf_{min}$, máxima $\mf_{max}$ y total $\mf_{total}$ de los subespacios de Krylov requerido por cada código para integrar la ecuación de prueba con tamaño de paso $h$, donde $\mf_{total}$ es la suma acumulativa de las dimensiones de los subespacios de Krylov en cada paso de integración. $d$ denota el número de ecuaciones en cada ejemplo.

Las tablas 4.1 - 4.5 muestran respectivamente los resultados en la integración de las ecuaciones de los cinco primeros ejemplos. 

De las tablas 4.1 y 4.2 se observa que, a pesar de realizar mayor cantidad de evaluaciones del campo vectorial y de requerir mayor total de subespacios de Krylov, los dos códigos LLRK son más rápidos que los dos códigos expms en la integración de las ecuaciones de los ejemplos StiffLinear y StiffNoLinear. Esto se debe a que en los códigos expms la aproximación de Krylov que se realiza consume el 51\% del tiempo de ejecución, mientras en los códigos LLRK similar cálculo consume solo el 42\% del tiempo. Por otra parte, toda vez que esas aproximaciones de Krylov son calculadas, la evaluación de las expresiones de cada esquema en los 4 códigos consume aproximadamente el 34\% del tiempo total de ejecución.

De las tablas 4.3 - 4.5 se observa que, en los tres restante ejemplos, los códigos LLRK son m\'as r\'apidos debido a que en general el tama\~no de los subespacios de Krylov es menor que el de los restantes m\'etodos y por tanto el total $\mf_{total}$ de los subespacios de Krylov requerido es menor. En estos ejemplos los jacobianos son matrices esparcidas lo que agiliza los c\'alculos y hace que la evaluaci\'on de estos sea muy r\'apida.

%\textcolor{red}{Hay que quitar de las tablas los valores de los parametros y los intervalo de tiempo, y pasarlo para donde estan los ejemplos (seccion 4.1). Nota que esos valores son los mismo para las simulaciones con paso fijo y paso variable.}

Los resultados de éstas simulaciones numéricas con códigos de tamaño de paso fijo y dimensión de Krylov variable muestran que los códigos LLRK4k y LLRK5k tienen precisión mucho mejor que los correspondientes c\'odigos expms4 y expms5, con similar o menor tiempo computacional.

\input{MainMatter/table0}
\input{MainMatter/table1}
\input{MainMatter/table2}
\input{MainMatter/table3}
\input{MainMatter/table4}
%\input{MainMatter/table5}

\newpage

\section{Simulaciones con códigos de paso variable}\label{Seccion simulacion paso variable}
El objetivo de éste segundo conjunto de pruebas es evaluar, mediante simulaciones, el desempeño de los esquemas embebidos introducidos en las secciones \ref{KRLOV-PADE} y \ref{KRLOV-PADE-FJ} con la estrategia adaptativa de la subsección \ref{adaptstrat} para la selección automática de la dimensión de Krylov y del paso de integración. Para ello se construyeron los códigos Matlab LLDP y LLDP-FJ que implementan, respectivamente, la mencionada estrategia adaptativa para los esquemas embebidos (\ref{LLDPK scheme}) y (\ref{LLDPKFJ scheme}).

Específicamente, el c\'odigo LLDP se construy\'o a partir del c\'odigo de Matlab ode45 sustituyendo
las f\'ormulas originales de Dormand y Prince
por las f\'ormulas localmente linealizadas~(\ref{LLDPK scheme}) y agregando las estrategias para
el control de la evaluaci\'on del Jacobiano de la subsecci\'on \ref{jaccontrol}, el control del tama\~no de 
paso de la subsecci\'on 
\ref{hcontrol}, la selecci\'on del orden de la aproximaci\'on de Pad\'e de la subsecci\'on \ref{pade-order} y 
la selecci\'on  de la dimensi\'on de Krylov de la subsecci\'on \ref{selkrydim}.
El c\'odigo LLDP construye un subespacio de Krylov en cada paso, que es lo que tiene el mayor costo computacional.
Tambi\'en calcula la exponencial de al menos una matriz peque\~na en cada paso. Posee una
estrategia para decidir cuando evaluar el Jacobiano y cuando conservarlo, lo que reduce el n\'umero de pasos en que
debe ser evaluado.

Similarmente, el c\'odigo LLDP-FJ se construy\'o a partir del c\'odigo de Matlab ode45 sustituyendo las f\'ormulas originales de Dorman y Prince
por las f\'ormulas localmente linealizadas~(\ref{LLDPKFJ scheme}) y agregando  las estrategias para la selecci\'on del orden de la aproximaci\'on de Pad\'e de la subsecci\'on \ref{pade-order} y la selecci\'on  de la dimensi\'on de Krylov de la subsecci\'on \ref{selkrydim}. A diferencia del código LLDP, el c\'odigo LLDP-FJ no eval\'ua el Jacobiano exacto, sino que aproxima el producto del Jacobiano por un vector mediante cociente diferencial de primero o segundo orden, pero esto aumenta el n\'umero de evaluaciones del miembro derecho de la ecuaci\'on. Este m\'etodo tambi\'en se construye un subespacio de Krylov en cada paso y se calcula al menos una exponencial de una matriz peque\~na. 

Para garantizar el orden de convergencia 5 establecido por Teorema \ref{Teorema Convergencia}, en el código LLDP se fija $m_{min}=5$. Análogamente, se fija $m_{min}=5$ en el código LLDP-FJ. 

Los resultados de códigos LLDP y LLDP-FJ en la integración de los problemas de prueba se compararán con los obtenidos por el c\'odigo adaptativo Exp4 tomado de~\cite{expode} que implementa el integrador exponencial de orden 4 de \cite{hochbruck1998exponential} con tamaño de paso variable. Similarmente se compararán con los resultados de los c\'odigos adaptativos ode15sk-fj y ode15sk que implementan las Backward Differential Formulas (BDF) hasta orden 5 con m\'etodos de subespacios Krylov, libre o no del uso de Jacobiano, respectivamente.

En particular, el código Exp4 construye al menos un subespacio de Krylov en cada paso de integración ya que, en general, se calculan varias $\phi$ multiplicadas por diferentes vectores. Además, al igual que los códigos de paso fijo expms4 y expms5, el código Exp4 utiliza la descomposición en valores propios de la matriz de Heissenber producida por el algoritmo de Arnoldi lo cual introduce un coste adicional en la descomposición de Krylov. El código exp4 no restringe los valores positivos que $m_{min}$ puede tomar.

El código ode15sk-fj se construyó a partir del c\'odigo Matlab ode15s sustituyendo los m\'etodos directos de soluci\'on
de sistemas de ecuaciones algebraicas lineales por m\'etodos iterativos de subespacios de Krylov. El código ode15sk se construyó de manera similar, pero manteniendo el uso de los m\'etodos directos cuando las matrices Jacobianas son densas. La idea de sustituir los m\'etodos directos por m\'etodos basados en subespacios de Krylov est\'an basadas en los art\'iculos \cite{shampinepde,zou2016} para hacer pr\'actica la evaluaci\'on de las BDF impl\'icitas para EDOs de grandes dimensiones con Jacobianos esparcidos.
En el caso del ode15sk se tom\'o el m\'etodo GMRES (función \emph{gmres} de Matlab) con precondicionador ILU(0) (función \emph{ilu} de Matlab) y para el ode15sk-fj el m\'etodo BICGSTAB (función \emph{bicgstab} de Matlab) utilizando el cociente diferencial para aproximar el producto del Jacobiano por un vector. Aquí, GMRES, BICGSTAB y ILU(0) son las siglas en ingles de los métodos  Generalized Minimal Residual, Biconjugate Gradient Stabilized y Incomplete LU factorization with 0 level of fill, respectivamente. En el código ode15sk se conserv\'o la aproximación a la matriz Jacobiana del código ode15s así como la  estrategia de reutilizaci\'on de la matriz Jacobiana de ese código. A diferencia del código anterior, el c\'odigo ode15sk-fj no aproxima la matriz Jacobiana, sino que aproxima el producto del Jacobiano por un vector mediante cociente diferencial. Específicamente, dentro de BICGSTAB se utiliza una aproximaci\'on por cociente diferencial de primer orden y fuera de este una aproximaci\'on de segundo orden tal y como se realiza en el c\'odigo LLDP-FJ~(ver secci\'on \ref{KRLOV-PADE-FJ}). Adem\'as, en el código ode15sk-fj no se utiliza un precondicionador porque nunca se tiene la matriz explícitamente y construir uno quedaría fuera del marco de este trabajo. 

Como en la subsección anterior, para cada ecuación de prueba, los resultados de la integración con cada uno de los códigos se presentan en una tabla. En cada tabla, se presenta el error relativo $ER$ y el tiempo de cómputo $Tiempo$ de cada código relativo al tiempo de cómputo del integrador ode15sk. Ademas, las tablas muestran el número de pasos aceptados  $NP$ y rechazados $NR$, así como  el número de evaluaciones del campo vectorial $f-Evals$ y de Jacobiano $J-Evals$. También se presenta la dimensión mínima  $\mf_{min}$, máxima $\mf_{max}$ y total $\mf_{total}$ de los subespacios de Krylov requerido por cada código para integrar la ecuación de prueba con tamaño de paso $h$. 
Para los códigos ode15sk y ode15sk-fj, $\mf_{min}$, $\mf_{max}$ es el número mínimo y máximo de iteraciones realizadas
para resolver un sistema lineal y $\mf_{total}$ es el número total de iteraciones realizadas a lo largo del tiempo. $EM$ denota el número de exponenciales matriciales calculadas, $DM$ la cantidad de descomposiciones de matrices, y $EL$ el número de sistemas lineales resueltos. Para el calculo del error $ER$, la  solución exacta de todas las ecuaciones de pruebas se estima con el código Matlab ode15s con tolerancias $RTol=10^{-12}$ y $ATol=10^{-14}$, excepto para la ecuación Stiff Lineal en que la solución exacta se aproxima utilizando (\ref{P-MA-2}) en cada punto de integraci\'on, y para la ecuación CUSP que se utiliza el código LLDP con $\mf_{min}=\mf_{max}=100$. Los cinco códigos son comparados en tres niveles tolerancias que llamaremos: cruda con $Atol=10^{-6}$ y $Rtol=10^{-3}$, media con $Atol=10^{-9}$ y $Rtol=10^{-6}$ y refinada con $Atol=10^{-12}$ y $Rtol=10^{-9}$. $d$ denota el número de ecuaciones en cada ejemplo.

 
Para hacer un análisis comparativo justo, los esquemas deben agruparse en dos grupos. El primero formado por los códigos ode15sk, LLDP y exp4 que evalúan o aproximan la matriz Jacobiana, y el segundo grupo conformado por los códigos ode15sk-fj y LLDP-FJ que no evalúan o aproximan la matriz Jacobiana.

\textbf{Stiff Lineal}\\
 La Tabla 4.6 muestra los resultados de la integración de la ecuación del ejemplo Stiff Lineal que tiene matriz Jacobiana $f_x$ densa y muy mal condicionada (aproximadamente $10^{20}$). De la tabla se observa que, del primer grupo de códigos, los códigos exp4 y LLDP son los m\'as precisos. Esto es un resultado esperado ya que los esquemas de esos códigos est\'an diseñados para resolver las ecuaciones lineales tan preciso como se requiera, lo cual no es el caso del código ode15sk. Notar que en el código LLDP la cantidad de evaluaciones del Jacobiano y el número total $\mf_{total}$ de subespacios de Krylov son mucho menor que el los del código exp4 lo cual justifica el menor costo computacional del primero. El código ode15sk requiere de mucho más pasos de integración y por tanto evalúa el miembro derecho de la ecuación muchas más veces. Del segundo grupo de códigos se puede apreciar que la precisión del código LLDP-FJ no mejora significativamente con respecto a la tolerancia. Esto se debe a que la aproximaci\'on de la derivada direccional por cociente diferencial en los esquemas (\ref{LLDPKFJ scheme}) no es buena. Respecto al tiempo el LLDP-FJ es el m\'as r\'apido ya que da muchos menos pasos que el ode15sk-fj y consecuentemente necesita de menos evaluaciones del $f$. 
 
\textbf{Stiff no Lineal}\\
La Tabla 4.7 muestra los resultados de la integración de la ecuación del ejemplo Stiff NoLineal que tiene matriz Jacobiana de $f$ densa. Del primer grupo de códigos se observa que, a pesar de utilizar dimensiones de los subespacios de Krylov menores que el código exp4, el código LLDP es el m\'as preciso. Esto se debe a que el código LLDP es de un orden de convergencia superior al del código exp4. En este ejemplo $\nnorm{f_x}_\infty\approx 1500$, lo que afecta la factorización $LU$~\cite{Golub96} llevada a cabo en el código ode15sk y por lo tanto la precisión. Respecto al tiempo, el código LLDP es el m\'as r\'apido ya que da menos pasos que el ode15sk, además, como el Jacobiano es una matriz densa entonces la descomposición y la resolución de los sistemas de ecuaciones algebraicas por métodos directos es más lenta. También el código LLDP utiliza subespacios de Krylov menores que el código exp4 y evalúa el Jacobiano unas pocas veces. Por el contrario, el código exp4 evalúa el Jacobiano en cada paso y como el Jacobiano es denso entonces es costoso evaluarlo. Del segundo grupo de códigos, el código LLDP-FJ es el m\'as preciso y es también el más rápido al requerir de menos evaluaciones de $f$.

\textbf{Brusselator}\\
La Tabla 4.8 muestra los resultados de la integración de la ecuación del ejemplo Brusselator. Del primer grupo de códigos, los códigos LLDP y ode15sk tienen una precisión muy similar. El LLDP es el más rápido para la tolerancias baja y media, pero no para la refinada. En este ejemplo $\nnorm{f_x}_\infty\approx 2\cdot 10^4$ y la condición del Jacobiano es aproximadamente $5\cdot10^4$ lo que en el caso del ode15sk hace que se rechacen muchos pasos y en el caso del LLDP se tenga que utilizar un tama\~no de paso bien peque\~no. Como el Jacobiano está implementado con matrices esparcidas su evaluación es poco costosa respecto a la evaluación del miembro derecho de la ecuación. Por esa razón, aun cuando el código ode15sk evalúa más el Jacobiano que el LLDP, el costo computacional que ello implica no compensa el tiempo de computo que el código LLDP utiliza en la evaluación de $f$. Del segundo grupo se puede observar, que  el código LLDP-FJ es m\'as preciso. Al no tener precondicionadores, las soluciones de los sistemas de ecuaciones algebraicas en el código  ode15sk-fj no son todo lo precisas que pudieran ser. El código LLDP-FJ es el más rápido pues evalúa el miembro derecho de la ecuación muchas menos veces que el ode15sk-fj.

\textbf{Burges}\\
La Tabla 4.9 muestra los resultados de la integración de la ecuación del ejemplo Burges. Del primer grupo de códigos, el código exp4 es el más preciso mientras que los códigos LLDP y ode15sk tienen una precisión similar pero menor que el exp4. Esto se debe a que el número total de subespacios de Kyolov requerido por el código exp4 para alcanzar la tolerancia requerida es 10 veces mayor que la requerida por los otros dos códigos. Esto junto con el doble de la cantidad de evaluaciones de $f$ explican también el porqué el código exp4 es mucho más lento que los otros dos. El código LLDP es el más rápido de todos a pesar de evaluar el miembro derecho el doble de veces que el ode15sk, pero el ode15sk tiene que resolver muchos sistemas de ecuaciones lineales. Por otra parte, los dos códigos del segundo grupo tienen una precisión muy similar. Respecto al tiempo, el código LLDP-FJ es más rápido que
el ode15sk-fj debido a que éste último requiere de una mayor cantidad de evaluaciones de $f$ y a que la cantidad de sistemas lineales 
que el código ode15sk-fj necesita resolver es el triple de la cantidad de exponenciales que el código LLDP-FJ necesita calcular.

\textbf{CUSP}\\
La Tabla 4.10 muestra los resultados de la integración de la ecuación del ejemplo CUSP. En este ejemplo $\nnorm{f_x}_\infty\approx4\cdot10^4$ y la condición de la matriz $f_x$ es de aproximadamente $10^6$. Este mal condicionamiento y norma no peque\~na de la matriz Jacobiana tienen un negativo impacto en la precisión con que se resuelven lo sistemas de ecuaciones lineales en del código ode15sk y por lo tanto en la precisión final del código, precisiones que no mejoran con respecto a las tolerancias. Similarmente, el código exp4 también se ve afectado por esas características de la matriz Jacobiana, pero la precisión se recupera en función de la tolerancia. Indudablemente, el código LLDP es el menos sensitivo a esa problemática y por lo tanto es el más preciso. Respecto al tiempo, el LLDP es el más rápido al requerir menor cantidad de pasos que los códigos exp4 y ode15sk. Este último tiene que resolver varios sistemas y descomponer matrices, esto es rápido porque las matrices son esparcidas, pero estas no son peque\~nas. El código exp4 además de dar gran cantidad de pasos, requiere de un gran número total de dimensión de Krylov para satisfacer la tolerancia requerida. 
En segundo grupo de códigos, el código LLDP-FJ es el más preciso mientras que la precisión del código ode15sk-fj presenta los mismo problemas del código ode15sk mencionados más arriba. El error relativo del código 
ode15sk-fj es malo desde el primer paso. El código LLDP-FJ es el más rápido, dado que el código ode15sk-fj requiere de más pasos de integración y de muchas más evaluaciones de $f$.
 
\textbf{DND}

%\textcolor{red}{ Hacer en el cluster simulaciones que faltan con exp4.}

La Tabla 4.11 muestra los resultados de la integración de la ecuación del ejemplo DND. En este ejemplo $\nnorm{f_x}_\infty\approx10^6$ y la condición la matriz $f_x$ oscila entre $10^5$ y $10^{16}$. Indudablemente, la norma infinita no peque\~na de la matriz $f_x$ provocan que el código LLDP tenga que reescalar el tamaño de paso $h$ para cumplir la condición de $\nnorm{h\cdot f_x}<54000$ lo que implican que se requieran de muchos pasos de integración. Similarmente, el código ode15sk también requiere, aunque en menor número, de una gran cantidad de pasos de integración para satisfacer la tolerancia requerida. El LLDP es el más preciso, mientras que el ode15sk y el
exp4 se comportan de forma similar respecto a la precisión. El ode15sk es en general el más rápido ya que tiene que
dar menos pasos y por tanto evaluar la función muchas menos veces, a su vez el LLDP es más rápido que el exp4 ya que
el total de subespacios de Krylov calculados es mucho menor.
En el segundo grupo el LLDP-FJ es el más preciso y más rápido que el ode15sk ya que da en general menos pasos y 
evalúa el miembro derecho de la ecuación diferencial muchas menos veces. Se puede notar que en general los 5 métodos
se ven afectados en mayor o menor medida por el mal condicionamiento y la norma infinita no peque\~na del Jacobiano.


\textbf{Brusselator 2D}

La Tabla 4.12 muestra los resultados de la integración de la ecuación del ejemplo Brusselator2D. En este ejemplo, el código LLDP es el más preciso, seguido del exp4. El exp4 da menos pasos que el ode15sk y, a pesar de que el exp4 resuelve más sistemas de ecuaciones lineales que el ode15sk, estos sistemas son muy peque\~nos en comparación a los que resuelve este último, de
ahí la demora del ode15sk. Por otra parte, el código LLDP requiere de menos  pasos de integración que el exp4 y de un menor número total de dimensiones de Krylov para satisfacer la tolerancia requerida, razón por la cual es el código más rápido. Para el segundo grupo el ode15sk-fj y el LLDP-FJ se comportan de forma similar respecto a la precisión, pero el LLDP-FJ tiene que evaluar muchas menos veces el miembro derecho de la ecuación diferencial, por lo que es mucho más rápido.
\\
\textbf{Allen-Cahn 2D}

La Tabla 4.13 muestra los resultados de la integración de la ecuación del ejemplo Allen-Cahn2D. En este ejemplo los códigos exp4 y el LLDP  son los que mejor aproximan la solución con similar precisión, y el exp4 es el más rápido de los códigos. Esto ultimo se debe que la cantidad evaluaciones del miembro derecho de la ecuación diferencial requeridas por el código exp4 es mucho menor que las que realiza el LLDP y a que, a pesar de que el exp4 resuelve más sistemas de ecuaciones lineales que el ode15sk, los sistemas que resuelven son de menor dimensión en comparación a los que resuelve el ode15sk. En el segundo grupo de códigos, el LLDP-FJ es el más preciso y también el más rápido. Esto último se debe a que, al aproximar la solución con menor cantidad de pasos, el código ode15sk-fj evalúa el miembro derecho de la ecuación diferencial mucho menos veces.
\\
\textbf{Gray-Scott 2D}

La última tabla muestra los resultados de la integración de la ecuación del ejemplo GrayScott2D. En este ejemplo, los códigos ode15sk y el LLDP tienen similar
 precisión y son, además, los más precisos. El LLDP es el más rápido, ya la cantidad evaluaciones que realiza del miembro derecho de la ecuación diferencial es mucho
  menor que la del exp4 y porque el costo computacional del algoritmo Krylov-Padé del LLDP es menor que el algoritmo  GMRES que utiliza el código ode15sk 
  para resolver sistemas de ecuaciones algebraicas. Para explicar mejor lo anterior, como la k-ésima iteración en ambos algoritmos tiene un coste de O(k$d$)
  \emph{flops}~\cite{matrixexp}, donde $d$ es el número de ecuaciones en el problema, una iteración de Arnoldi es equivalente aproximadamente a una iteración
  de GMRES y así $\mf_{total}$ puede usarse para comprar el costo de ambos algoritmos. Además, el cálculo de la exponencial matricial es por mucho menos 
  costoso que descomponer matrices aunque sea con ILU(0) ya que aproxi\-mar la exponencial por Padé tiene un costo de 
  $2( \pf+ \max( 0\mathord{.}1+\lfloor\log_2(\nnorm{H}_\infty)\rfloor ) + 1/3 )\mf^3 flops$~\cite{matrixexp}, donde $H$ es la matriz de Heissenber y 
  $\mf$ es la dimensión del subespacio de Krylov; en cambio el algoritmo ILU(0)\cite{saad2003iterative,hysom2002level} tiene un costo de $O(cd)$,
  donde $d$ es el número de ecuaciones en el problema con $c$ una constante $c\ll d$ y $5\leq\mf\leq30 \ll d$. El LDP-FJ es también el código más rápido 
al requerir de muchos menos pasos de integración que el ode15sk-fj y por tanto de muchas menos evaluaciones del miembro derecho de la ecuación diferencial.

\section{Sumario de los resultados de las simulaciones numéricas}

Los resultados de las simulaciones numéricas con códigos de tamaño de paso fijo y dimensión de Krylov variable realizadas en la Sección  \ref{Seccion simulacion paso fijo} muestran que los nuevos códigos LLRK4k y LLRK5k tienen precisión mucho mejor que los conocidos c\'odigos expms4 y expms5, con similar o menor tiempo computacional.

Los resultados de las simulaciones con códigos de tamaño de paso y dimensión de Krylov variable obtenidos en la Sección \ref{Seccion simulacion paso variable} muestran que el nuevo c\'odigo LLDP-FJ tiene precisión similar o mejor que el c\'odigo ode15sk-fj, con un menor tiempo de cómputo. También se puede apreciar que el nuevo c\'odigo LLDP es, en general, mucho m\'as r\'apido que los códigos Exp4 y ode15sk, con precisi\'on similar o mejor.
		
En general, para problemas de valor inicial con matriz Jacobiana esparcida, los m\'etodos que eval\'uan la matriz Jacobiana son m\'as r\'apidos que los libre de Jacobiano, ya que el costo de evaluar la funci\'on es mucho mayor que el de evaluar la matriz Jacobiana y los métodos libre de Jacobiano tienen que evaluar la funci\'on muchas más veces. Lo opuesto ocurre cuando la $\nnorm{.}_\infty$ de la matriz Jacobiana es muy grande. En éste caso, el producto de la matriz Jacobiana por un vector usualmente acarrea considerables errores de redondeo lo que motiva la disminución drástica del tamaño de paso y el consecuente aumento del número de pasos de los integradores que eval\'uan la matriz Jacobiana. Por ésta razón, los integradores libre de Jacobino suelen ser más rápido en ésta situación. 
La reutilización del Jacobiano calculado en pasos anteriores cuando es posible, disminuye el tiempo de cómputo de los métodos que utilizan esta estrategia. Al evaluar el Jacobiano menos veces se realizan menos  operaciones, sobre todo si el Jacobiano es grande o si es una matriz densa. Como para reutilizar el Jacobiano se exige que su variación cumpla con las tolerancias requeridas la precisión del esquema numérico no se afecta.
%\textcolor{red}{Mencionar los beneficios de la estrategia para reutilizar el Jacobiano calculado en pasos anteriores cuando es posible.}
Cuando la norma infinita de Jacobiano es grande y este está muy mal condicionado entonces todos los métodos se ven afectados tanto en precisión como en tiempo de cómputo, un ejemplo de esto es la ecuación DND.
 
%\textcolor{red}{Hay que mencionar la combinacion fatal de norma de jacobiano grande con mal condicionamiento para todos los códigos}

\section{Detalles de implementaci\'on}

Con la excepción de los dos primeros ejemplos, en los restantes, los jacobianos del campo vectorial se representan con matrices esparcidas. En la mayor\'ia de estos ejemplos el Jacobiano tiene una estructura que permite que su implementaci\'on sea eficiente ya que se pueden precalcular ciertas partes, adem\'as de que est\'an implementados utilizando matrices esparcidas. Por esto la evaluaci\'on del Jacobiano es igual o menos costoso que el de la funci\'on. El Jacobiano de la ecuaci\'on Stiff Lineal es constante por lo que se
calcula la primera vez y luego se retorna la matriz calculada el resto de las llamadas, de ahí que el costo de su evalución es casi nulo. 
Los tamaños de paso máximo y mínimo permisibles se definen por $h_{max}=0\mathord{.}1\cdot(T-t_0)$ y $h_{min}=16\epsilon_{mach}\cdot 10^{\lceil\log_{10}(t_n)\rceil}$, respectivamente, donde $\epsilon_{mach}\approx 5\cdot 10^{-16}$.

\input{MainMatter/tablea1}
\input{MainMatter/tablea2}
\input{MainMatter/tablea3}
\input{MainMatter/tablea4}
\input{MainMatter/tablea5}
\input{MainMatter/tablea6}
\input{MainMatter/tablea7}
\input{MainMatter/tablea8}
\input{MainMatter/tablea9}
%\input{MainMatter/tablea10}
%\input{MainMatter/tablea11}